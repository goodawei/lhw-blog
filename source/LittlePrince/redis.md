一. 使用redis 实现分布式锁的问题。
	
	问题： 主要是死锁问题

	出现死锁的主要场景：

	1. setnx 后 业务处理后释放锁， 业务处理异常无法保证执行释放逻辑产生死锁。

	2. 加上过期时间， setnx 和 设置过期时间 低版本 不是一个事务，低概率出现不一致，另一方面是业务处理时间过长 超过了锁的过期时间。


二. 解决办法

	1. 从业务场景上避免
	2. lua script 可以做到多条指令的一致性。 重要的业务逻辑可以写在lua script 里


三. 使用redis 实现队列
	1. 使用bpop, 使用阻塞读取， 避免循环占用链接不释放。但是此时要注意捕获异常重试，闲置久了会抛出一个异常.
	2. 多线程消费要注意重复消费，解决办法利用单线程返回值关键，同时可以用lua脚本降多个命令原子化，存入用zset。
	3. 优点比较简单，使用过 Rabbitmq 的同学知道它使用起来有多复杂，发消息之前要创建 Exchange，再创建 Queue，还要将 Queue 和 Exchange 通过某种规则绑定起来，发消息的时候要指定 routing-key，还要控制头部信息

四. 数据结构 bitmap
	
	说起bitmap,首先要了解redis中的 string 类型，其实string类型的底层就是有字节数组组成的（字符串视为一个位数组），只不过他是一个可以动态扩容的数组，而字节数组在向下一层就是位数组了，也就是bitmap.

	一个字符串在内存中存储的字节数组如下：

	0 1 0 0 1 0 0 1  

	7 6 5 4 3 2 1 0  这是字节的二进制位顺序 低位到高位 从右=》左

	0 1 2 3 4 5 6 7  这是位数组的索引位置 从左=》右， 业务中对bitmap索引的获取和修改，都是用位数组索引，也就是书中说的偏移量。redis的数组是动态扩容的，所以这个索引一定是顺序自增的。

	签到实例应用：

	使用bitmap首先要考虑 key 和 偏移量的设计，

	如签到： 

	可以将用户id作为key， 日期天数作为偏移量： setbit u:100:202008 26 1 

	也可以用日期作为key 用户ID作为偏移量： setbit date:202008  100 1 

	不同的选择对于数据的取法不一样，具体看业务的需求。常用的命令： bitcount u:100:202008  ， bitpos u:100:202008 1 

五. 	hyperloglog

	他的功能是去重统计，set, hashtable 数据结构同样可以实现去重并统计，但是hyperloglog 最多只占用12k空间，计算公式： 16384*6/8/1024

	原理：它不存储数据结合本身，而是利用概率学原理推算出数据结果，并将误差控制在一定范围内。

	概率学源自：伯努利试验。

	误差控制： 调和平均

	公式推导： 一枚硬币抛上落下其 正反面的概率均为50%， 如果我们做m组实验，每一组记录抛出证明结果的次数k，并最终得出m组中最大的k 记为maxk, 则 m 和 maxk 有一定的线性关系： m = 2 ^ maxk; 由此可以推倒出 m值。

	在redis中，给出一组待求的随机数 n, 要做的实验组 m = 16384, 每个随机数的hash值的二进制低位连续0的个数为k, 并得出每个桶的最大k为maxbit,通过m组的实现得出目前所有随机数的调和平均maxbit， 由此推导出元素个数n=2^maxbit