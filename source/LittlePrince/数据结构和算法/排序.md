时间复杂度在平方阶的算法：

1. 冒泡

	原理是比较和交换, 属于稳定排序，每一轮的冒泡都会排出一个值。

2. 插入
	
	原理是比较和移动，左侧区间为已排区间，右侧为未排区间，每次从右侧选择一个，放置到左侧正确的位置。 属于稳定排序

3. 选择	

	原理是比较和移动，左侧区间为已排区间，右侧为未排区间，每次从右侧选择一个正确的元素，放置到左侧正。 属于不稳定排序


时间复杂度为对数阶的算法：原理都是利用了 分治思想

1. 快排 

arr  低位游标(初始值：0) ， 高位游标(初始值数组长度)

入口函数: quick_sort()

递归函数: sort(arr,low,high)

分治函数: partition(arr,low,high)

交换函数: swap(arr,a,b)

递归函数逻辑： 当低位游标 < 高位游标时， 通过分治函数获取一个中心点 pivot ，然后开始递归，递归分为2部分，一部分递归区间为 低位游标 low 至 pivot-1，另一部分区间为 中心点 pivot+1 至 high. 

sort(arr, low, pivot-1)
sort(arr, pivot+1, high)

分治函数逻辑： 

	1. 第一次选举一个pivot，默认以低位第一位游标坐在的值。

	2 。然后高位游标开始游动(游动的目的是从最右侧开始找到一个比当前pivot小的然后交换，也就是说争取pivot值，把小于pivot的交给低区)，所以游动的逻辑是，当右侧最高值 arr[high] >= arr[ivot] 时开始游动 high-- ,否则不游走，保留当前就是要的最大值。然后通过交换函数进行交换，当前的低位游标与当前的高位游标数据交换。

	3. 然后低位游标开始游动(游动的目的是从最左侧开始找到一个比当前pivot大的然后交换，也就是说争取pivot值，把大于pivot的交给高区)，所以游动的逻辑是，当右侧最低值 arr[low] <= arr[ivot] 时开始游动 low++ ,否则不游走，保留当前就是要的最小值。然后通过交换函数进行交换，当前的低位游标与当前的高位游标数据交换。

	4. 完成第一轮后将low 或者 high 返回给递归，进行下一轮。

2. 归并