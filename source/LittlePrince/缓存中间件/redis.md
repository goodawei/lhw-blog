一. 使用redis 实现分布式锁的问题。
	
	问题： 主要是死锁问题

	出现死锁的主要场景：

	1. setnx 后 业务处理后释放锁， 业务处理异常无法保证执行释放逻辑产生死锁。

	2. 加上过期时间， setnx 和 设置过期时间 低版本 不是一个事务，低概率出现不一致，另一方面是业务处理时间过长 超过了锁的过期时间。


二. 解决办法

	1. 从业务场景上避免
	2. lua script 可以做到多条指令的一致性。 重要的业务逻辑可以写在lua script 里


三. 使用redis 实现队列
	1. 使用bpop, 使用阻塞读取， 避免循环占用链接不释放。但是此时要注意捕获异常重试，闲置久了会抛出一个异常.
	2. 多线程消费要注意重复消费，解决办法利用单线程返回值关键，同时可以用lua脚本降多个命令原子化，存入用zset。
	3. 优点比较简单，使用过 Rabbitmq 的同学知道它使用起来有多复杂，发消息之前要创建 Exchange，再创建 Queue，还要将 Queue 和 Exchange 通过某种规则绑定起来，发消息的时候要指定 routing-key，还要控制头部信息

四. 数据结构 bitmap
	
	说起bitmap,首先要了解redis中的 string 类型，其实string类型的底层就是有字节数组组成的（字符串视为一个位数组），只不过他是一个可以动态扩容的数组，而字节数组在向下一层就是位数组了，也就是bitmap.

	一个字符串在内存中存储的字节数组如下：

	0 1 0 0 1 0 0 1  

	7 6 5 4 3 2 1 0  这是字节的二进制位顺序 低位到高位 从右=》左

	0 1 2 3 4 5 6 7  这是位数组的索引位置 从左=》右， 业务中对bitmap索引的获取和修改，都是用位数组索引，也就是书中说的偏移量。redis的数组是动态扩容的，所以这个索引一定是顺序自增的。

	签到实例应用：

	使用bitmap首先要考虑 key 和 偏移量的设计，

	如签到： 

	可以将用户id作为key， 日期天数作为偏移量： setbit u:100:202008 26 1 

	也可以用日期作为key 用户ID作为偏移量： setbit date:202008  100 1 

	不同的选择对于数据的取法不一样，具体看业务的需求。常用的命令： bitcount u:100:202008  ， bitpos u:100:202008 1 

五. 	hyperloglog

	他的功能是去重统计，set, hashtable 数据结构同样可以实现去重并统计，但是hyperloglog 最多只占用12k空间，计算公式： 16384*6/8/1024

	原理：它不存储数据结合本身，而是利用概率学原理推算出数据结果，并将误差控制在一定范围内。

	概率学源自：伯努利试验。

	误差控制： 调和平均

	公式推导： 一枚硬币抛上落下其 正反面的概率均为50%， 如果我们做m组实验，每一组记录抛出证明结果的次数k，并最终得出m组中最大的k 记为maxk, 则 m 和 maxk 有一定的线性关系： m = 2 ^ maxk （2的多少次方）; 由此可以推倒出 m值。

	在redis中，给出一组待求的随机数 n, 要做的实验组 m = 16384, 每个随机数的hash值的二进制低位连续0的个数为k, 并得出每个桶的最大k为maxbit,通过m组的实现得出目前所有随机数的调和平均maxbit， 由此推导出元素个数n=2^maxbit

六. 布隆过滤器

	同样是一款去重功能的数据结构， 它能够知道一个元素是否存在，它同样不记录元素数据本身，而是记录一个布尔值，它的原理是这样的：添加元素时首先会向内存申请空间，这个空间用来存放的是位数组。

	二 要素： 

	1 是底层数据结构是位数组	。
	2 准备3个hash函数。

	当调用bfadd() 时候，会将元素分别通过三个hash 函数进行哈希运算，运算后的每个hash值，分别对数组的长度取模，然后对应到数组的下标上后值设置为1.

	当调用bfexist()时候，同样会分别通过三个hash 函数进行哈希运算，然后判断数组中的位置，只要有一个是0则元素一定不存在。如果都是1则 返回存在，但是有一定的错误概率，因为这个元素有可能是hash碰撞了一个已存在的元素。错误的概率大小主要取决于数组的长度以及元素的数量。

七. 基于经纬度存储接口 geohash

	能够方便的通过经纬度来计算距离，获取距离，附近距离等。

八。 限流
	
	1. 基于滑动窗口的限流
	2. 基于容量和匀速速率的限流 （漏洞）	
	3. 令牌桶


九. redis 主从配置
	1. 基本原理： master node 配置 slave node, slave node 配置 master node的host & ip & password, 当slave node 第一次启动链接master node的时候会发送一个psync 命令，master接收到请求后，会通过bgsave 生成rdb文件，而新的客户端写命令会保存到缓存，slave node 接收RDB文件会先落盘，在加载到内存。master 在将内存缓存的命令同步到slave， 后续master会通过异步方式将写命令同步给slave.

	2. 解决master 的单点问题， sentry 进程。 每个节点都会启动 sentry进程，注意主从的sentry的配置文件配置不一样,当master异常退出后，其中一个slave node 会充当master，具有写权限。

	3. cluster 多写多读。

十. 数据过期淘汰策略

	1. 惰性删除， 访问key的时候看其是否过期， 对cpu友好，对内存比较浪费。
	2. 定期删除， redis 维护一个过期字典，使用时间事件轮询，轮询过的键值对进行释放，轮询时间可以配置，
	3. 主动删除， 原因是物理内存是有大小限制的，当超过内存预警（配置文件里配置的内存阀值），发生写操作时会触发，淘汰策略包含，lru, random 等。

十一. 持久化
	1. RDB
	2. AOF
	3. 混合




