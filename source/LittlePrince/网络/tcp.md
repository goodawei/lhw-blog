TCP 窗口缩放、时间戳和 SACK

Linux TCP 协议栈具有无数个可以更改其行为的 sysctl 旋钮。 这包括可用于接收或发送操作的内存量、套接字的最大数量、可选的特性和协议扩展。

默认套接字的最大数量：1024.


TCP 可以承受的数据传输速率受到几个因素的限制。其中包括：

往返时间(Round trip time)（RTT）这是数据包到达目的地并返回回复所花费的时间。越低越好。


窗口缩放选项： 

窗口缩放 选项告诉对等方，应该使用给定的数字缩放 TCP 标头中的接收窗口值，以获取实际大小。三次握手的时候告知。


在服务器端建立 TCP 连接:

	当连接请求到达的速度快于服务器应用程序可以接受新的传入连接的速度时，连接积压最终将达到其极限。这可能是由于系统配置错误或应用程序中的错误引起的。当一个或多个客户端发送连接请求而不对 “SYN ACK” 响应做出反应时，也会发生这种情况。这将用不完整的连接填充连接队列。这些条目需要几秒钟才会超时。这被称为 “同步泛洪攻击”(syn flood attack)。

https://www.toutiao.com/i6882575775585796615/


TCP报文结构：

	源端口： 4字节 16bit, 目标端口16bit  
	序号：   4字节 32bit 
	确认序号：4字节 32bit
	部首长度：4字节 4bit 预留位 6bit 标志位 6bit：SYN ACK FIN PSH  16bit 窗口大小 
	校验和、紧急指针
	数据段：


为什么是3次握手。
	客户端A包发出后，网络延时服务端为及时作出ACK， 客户端又重新发送B数据包，服务端成功应答ACK，客户端也成功应答服务端的ACK，开始发送和接收数据，然后4次挥手断开，而此时服务端又收到了A数据包，并应答ACK，而此时客户端已经关闭状态无法应答。

	以上说法不完全正确，首先tcp是可靠的安全的传输协议，之所以可靠，是因为客户端和服务端在传输数据之前，不但必须确保双方都具有传输和接收的能力，还要确保自己接收的数据包能够按顺序拼接，从tcp的数据报文结构上看，tcp是通过，序号，和确认序号，以及标志位，来保证数据的完整性和顺序性。第一次握手客户端发送的报文结构： 标志位SYN置1， 随机生成一个序号seq=x  (告诉服务端发送数据的起始序号是x), 服务端接收到报文后，第二次握手： 标志位ACK置1，确认序号ack=x+1 （告诉客户端我已经准备好接收序号为x+1的数据了）标准位SYN置1，随机生成序号seq= y（告诉客户端我发送的数据的起始序号是y）,客户端接收的报文后，第三次握手：标志位ACK置1，确认序号ack=y+1（告诉服务端我已经准备好接收序号为y+1的数据了）,生成序号seq=x+1 (因为第二次握手，服务端告诉了客户端他准备接收的数据序号是 x+1，虽然第三次握手还没有数据，但是从这里就开始消耗序号了),  从这个过程来看，如果是2次握手，那么客户端是不能完全确定是否能够知道服务端发送的起始序号y了,这样在就会有问题。


为什么是4次挥手。
	标志位由 SYN 改为 FIN.序号和确认序号的使用不变。
	
	第一次挥手：客户端发送FIN数据包，标志位FIN置1，序号seq=x, 服务端接收到报文，发现是FIN表示客户已经不再发送数据了，但是服务端有可能还没有收到或者处理完后续的序号数据包，所以此时服务端会先向客户端发送一个ACK报文和确认序号 为第二次挥手， 待数据处理完成后会在发送服务端的FIN包，发送完成服务端进入 close wait状态，为第三次挥手， 客户端应答服务端FIN，发送ACK后进入TIME WAIT 状态，为第四次挥手，服务端必须收到第四挥手的ACK才关闭，否则重新发送第三次挥手的数据包，而客户端会维持一个默认2h的time wait 状态。就是为了重新发送第三次挥手的数据包保留的。

	TIME WAIT： 时间默认2h,主要原因是避免客户端向服务器发送的最后一次应答（也就是第四次挥手失败），服务端没有收到，服务端没有收到会重新发送FIN数据包，而此时如果没有TIME WAIT 窗口期，服务端将一直停留在close wait状态。

