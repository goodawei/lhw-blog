隔离级别: 谈起隔离级别，涉及的感念主要有 一致性读（快照读）， 当前读（读已提交的事务）当前读会结合着锁的使用。

读未提交， （脏读） 读取人家未提交的内容

读已提交，（不可重复读） 导致前后读取的内容不一致

可重复读rr（幻读的定义：同一事务中前后两次相同的查询读到的行数不一致，出现在当前读的场景如 for update，其他已提交事物的update和insert都可能导致其他事物出现行数不一致，而insert导致的称为幻读）一般解决幻读的方法是增加范围锁RangeS

串新化


多版本并非控制访问： MVCC, 这里也会涉及到的概念有： 一致性读（快照读）, 和 当前读， 和 undo log.

一致性读原理： 每一个事务开启的时候都会起一个快照，这个快照主要标记的有 当前事务的ID，已提交的事务的ID（已提交的事务ID又分为：当前视图开启前提交的，当前事务开启后提交的 ），当前开启单未提交的事务ID。抽象到平面区间大概如下：

【 已提交的事务 ------ 当前视图开启区间 ---- 已提交的事务 ---- 未提交的事务 】

在这个事务中读取的时候只能读取到 当前事务，和当前事务视图开启前已提交的内容。

当前读原理： 首先当前读要解决的问题是rr级别下更新丢失的问题，像 update 本身就是一个事务，他会直接去读最新的已提交事务的最新值，但是当前读要结合锁的使用。


undo log： 数据空中的 行 row, 在多个不同的事务中，会存在多个不同的版本，每个版本都会记录当前版本的状态值，和当前版本的视图。







事务启动时的视图可以认为是静态的，不受其他事务更新的影响。同时mysql会为每条记录在更新的时候都会同时记录一条回滚操作。

当同时存在成千上万的事物时，由于每个事物的时间段不同，所有它们的视图窗口也并不一样，不同时刻启动的事务会有不同的read-view，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC），这种情况会不会重新更新丢失问题。


mvcc是有undo实现的，undo又是有redo 引起生成，默认事务是rr, redo 要做undobuffer 日志。redo 相当于利用快慢指针思想，有一个checpoint 在往前推进 将buffer写入磁盘，同时有一个write在不停的忘里写入新数据。



不会出现更新丢失问题：

首先我们要知道一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读。事务里更新会有这样一条规则：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read），而不是快照读，如果用普通的select读取，读到的确实是快照的数据。



可重复读的核心就是一致性读或者快照读、当前读和行锁就串起来了。 当前读为了解决其他事物更新丢失，行锁，为了解决脏读和更新丢失。


可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。


索引原理：充分利用磁盘的预读原理（每次读取4kb or 16kb），索引innodb每个层级块的大小也是16kb，这个空间大小配置固定，那么能够存储多少索引数据就要依赖数据类型了，所以我们设计的字段类型大小要合理，betree- 数每层存储的既有索引又有数据，这样导致他的层级会很高，所谓的卫星数据，而betree+ 数据都在叶子节点，而redis的skiplist要结合内存（空间换时间）。


覆盖索引： 不涉及的回表问题，重点是select的字段如果就在索引上就不用回表，联合索引场景命中率可能会多一些。主要是要注意写法。

排序： 排序原理是在sort buffer 里排，大小配置固定，超出配置就要申请磁盘临时表，排序也会设计覆盖索引，回表等问题。





字段类型：

char（len）与varchar（len）后面接的数据大小为存储的字符数，而不是字节数。

varchar中 65535是 单行的总字节数的限制，具体换成字符还要剪去起始位置 -1，长度位 -2 ，在除以 3.
char 就是最大255


内存与磁盘的交互单位是页，页的结构如下：

读取的单位是页一般16kb，这种读法称为预读，具体细节好要去了解磁盘的构造，扇区大小等，每一个页有自己的页号（页号又是每页的最大记录id,组成的链表），innodb 也为页构建了一个页级索引，查找的时候可以快速定位在哪一页 （二分查找）。

页里记录了索引， 列的信息等，主要包括：头信息、变长字段的长度（如varchar, 2个字节 65535，减去长度位 ？）、null值长度（索引null值是占用空间的）、数据区域、指针区域等。

同时页里面的数据会进行分组(又称为槽)，每组把组内最大id提取出来组成一个数组(一个槽指向的该组的最大值(主键) 和页的最大值类似), 查找的时候使用二分查找定位在哪一组，而组的小标是一个列表，也就是组内的元素，整体是个hashtable.



