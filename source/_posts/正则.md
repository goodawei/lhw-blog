---
title: 深入理解正则表达式 
date: 2017-02-25 19:58:37
tags: 正则
categories: php
---

### 表达式测试 :bee:

推荐一个测试地址 http://www.rexv.org/
测试题：用单引号和双引号匹配 `\$`
答案 ： 首先`\$`都是元字符都需要转义，转义结果为：`\\\$`
- 用单引号来标识的正则: `/\\\\\$/`
- 用双引号来标识的正则: `/\\\\\\\$/`

### :palm_tree: 分组和后向引用 

通过次数限定符，来限定前面括号中的单元。匹配到的单元将会被捕获，捕获到的内容可以在正则表达式的后面通过`\1,\2,\3`获取。

### 贪婪与非贪婪 :beetle:

- `.*` 贪婪模式，贪婪模式会回溯匹配效率低。
- `.*?` 非贪婪模式

<!-- more -->

### 正则表达式的回溯

```php
    /".*"/ 和 /".*?"/
    分别匹配 'my name is "lhw" who "are" you '
```

- `".*"`匹配过程：当匹配到第一个`"`字符的时候由于`.`是匹配非换行符的所有字符，所以就从`"`一直匹配的最后，匹配到最后然后在逐次往前回溯，拿每个字符和最后一个`"`符号匹配，直到匹配到为止，所以`".*"`匹配的结果是 "lhw" who "are"

- `".*?"`匹配过程：当匹配到第一个`"`字符的时候，就会逐次的从当前的`"`后面的字符和最后`"`做匹配。直到匹配为止。


### :scissors: 限定符和元字符使用时注意
- 所有限定符都是限定它前面的一个子单元出现的次数。
- 只有元字符出现在它该出现的地方才能起到元字符作用，否则就是普通字符如：
[-0-9A-Z.?]由于[]优先级高于`.?`所以这里的`.?`就是普通字符


### PCRE 主要函数

- preg_grep 返回匹配模式的数组条目
- preg_match 执行一个正则表达式匹配
- preg_match_all 执行一个全局正则表达式匹配
- preg_filter 执行一个正则表达式搜索和替换
- preg_replace 执行一个正则表达式搜索和替换
- preg_replace_callback 执行一个正则表达式搜索且使用一个回调进行替换
- preg_split 通过一个正则表达式分割字符串


### 正则表达式 - 元字符 :pig_nose:

字符    | 描述
-------|--------------------
\      | 有三种含义，1是转义如 `\\`,`\(`,2是特殊字符如`\n` 匹配一个换行符,3是向后引用
^      | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置
`$`      | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multilin性，$也匹配“\n”或“\r”之前的位置
*  | 匹配前面的子表达式零次或多次(注意：前面的子表达)。例如，lhw* 能匹配 "lh"和"lhw" 以及 "lhwww"。等价于{0,}
+  | 匹配前面的子表达式一次或多次。例如，'lhw+' 能匹配 "lhw" 以及 "lhwww"，但不能匹配 "lh"。+ 等价于 {1,}
?  | 匹配前面的子表达式零次或一次。例如，"lhw(nb)?" 可以匹配 "lhw" 或 "lhwnb" 等价于 {0,1}
{n}  | 匹配确定的 n 次。例如，'lhw{2}' 不能匹配 "lhw" 但是能匹配 "lhww"
{n,} | 至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foood" 中的所有 o,'o{1,}' 等价于 'o+','o{0,}' 则等价于 'o*'
{n,m} | 最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooood" 中的前三个 o。'o{0,1}' 等价于 'o?'
.  | 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式
? | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'
x\|y | 匹配 x 或 y。例如，'z\|food' 能匹配 "z" 或 "food"。'(z\|f)ood' 则匹配 "zood" 或 "food"
[xyz] | 匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'
[^xyz] | 匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'
[a-z] | 匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符
[^a-z] | 匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符
\d | 匹配一个数字字符。等价于 [0-9]
\D | 匹配一个非数字字符。等价于 [^0-9]
\n | 匹配一个换行符
\s | 匹配任何空白字符，包括空格、制表符、换页符等等
\S |匹配任何非空白字符。等价于 [^ \f\n\r\t\v]
\r | 匹配一个回车符
\t | 匹配一个制表符
\w | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'
\W | 	匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'
\xn | 十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码
\nm | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm
[\u4e00-\u9fa5] | unicode码范围，匹配任意汉字，\u固定写法，4e00为16进制的unicode编码