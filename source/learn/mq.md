RabbitMQ 

一个task对应多个worker模式下，会采用轮训的方法送给每一个worker（应该是每条消息hash后会固定到一个work上）,一旦送达改task会标记删除，但是每个woker处理消息是需要时间的，一旦worker死掉，那么改任务就会丢失，为了保证任务不丢， RabbitMQ supports message acknowledgments.


如果使用者在不发送ack的情况下死亡（其通道已关闭、连接已关闭或TCP连接已丢失），RabbitMQ将理解消息未完全处理，并将对其重新排队。如果同时有其他消费者在线，它会很快将其重新交付给另一个消费者。这样你就可以确保没有信息丢失，即使工人偶尔死亡。


轮训方式的缺点：


你可能已经注意到调度仍然不能完全按照我们的要求工作。例如，在有两个工人的情况下，当所有的奇数消息都很重，而偶数消息很轻时，一个工人将一直很忙，而另一个工人几乎不做任何工作。好吧，RabbitMQ对此一无所知，仍然会均匀地发送消息。这是因为RabbitMQ只在消息进入队列时发送消息。它不会查看消费者未确认消息的数量。它只是盲目地将第n条消息发送给第n个消费者。



worker的工作相当于是amqp协议=》cgi协议。 这一层可以用golang实现一个中间层转换多种协议。



### 发布订阅

Essentially, published log messages are going to be broadcast to all the receivers.

实际上，发布的日志消息将被广播给所有的接收者。


RabbitMQ消息传递模型的核心思想是，生产者从不将任何消息直接发送到队列。实际上，生产者常常根本不知道消息是否会被传递到任何队列。


exchange: 它的作用，以及所属位置有点类似于哨兵模式，生产者只能向exchange发送消息。exchange是一件很简单的事。一方面它接收来自生产者的消息，另一方面它将它们推送到队列中。exchange必须确切地知道如何处理它接收到的消息。是否应将其附加到特定队列？还是附加到许多队列中？或者应该被丢弃。其规则由exchange类型定义。




