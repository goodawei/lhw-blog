rr 级别

mvcc 

事务 for update 当前读可能出现幻读。


事务： ACID 特性


隔离级别: 

读未提交， （脏读） 读取人家未提交的内容

读已提交，（不可重复读） 导致前后读取的内容不一致

可重复读rr（幻读） 出现在当前读的场景如 for update ，会对其他事物insert的数据读取到。一般解决幻读的方法是增加范围锁RangeS

串新化


事务启动时的视图可以认为是静态的，不受其他事务更新的影响。同时mysql会为每条记录在更新的时候都会同时记录一条回滚操作。

当同时存在成千上万的事物时，由于每个事物的时间段不同，所有它们的视图窗口也并不一样，不同时刻启动的事务会有不同的read-view，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC），这种情况会不会重新更新丢失问题。


mvcc是有undo实现的，undo又是有redo 引起生成，默认事务是rr, redo 要做undobuffer 日志。redo 相当于利用快慢指针思想，有一个checpoint 在往前推进 将buffer写入磁盘，同时有一个write在不停的忘里写入新数据。



不会出现更新丢失问题：

首先我们要知道一个概念，叫作当前读。其实，除了 update 语句外，select 语句如果加锁，也是当前读。事务里更新会有这样一条规则：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read），而不是快照读，如果用普通的select读取，读到的确实是快照的数据。



可重复读的核心就是一致性读或者快照读、当前读和行锁就串起来了。 当前读为了解决其他事物更新丢失，行锁，为了解决脏读和更新丢失。


可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。


索引原理：充分利用磁盘的预读原理（每次读取4kb or 16kb），索引innodb每个层级块的大小也是16kb，这个空间大小配置固定，那么能够存储多少索引数据就要依赖数据类型了，所以我们设计的字段类型大小要合理，betree- 数每层存储的既有索引又有数据，这样导致他的层级会很高，所谓的卫星数据，而betree+ 数据都在叶子节点，而redis的skiplist要结合内存（空间换时间）。


覆盖索引： 不涉及的回表问题，重点是select的字段如果就在索引上就不用回表，联合索引场景命中率可能会多一些。主要是要注意写法。

排序： 排序原理是在sort buffer 里排，大小配置固定，超出配置就要申请磁盘临时表，排序也会设计覆盖索引，回表等问题。





字段类型：

char（len）与varchar（len）后面接的数据大小为存储的字符数，而不是字节数。

varchar中 65535是 单行的总字节数的限制，具体换成字符还要剪去起始位置 -1，长度位 -2 ，在除以 3.
char 就是最大255



