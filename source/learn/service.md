服务化的目的：

单体应用的缺点： 耦合，相互牵扯，扩展、演进难度大。

微服务的优点：编辑清晰，扩展、技术栈、演进更灵活，但是相应的带来了管理上的难度。

微服务要解决的一些问题：

1. apigateway , 每一个服务都有对外提供接口的能力，服务多了，就需要api网关进行统一管理，网关可以对服务、路由、插件、鉴权等等进行统一管理。

2. 服务间内部调用，rpc框架，可以自严，也可以选开源产品如grpc等。
   
   目前大概使用方向是这样的： PHP为例服务提供者将每一个服务提供的接口规划为一个公共仓库，客户端使用的时候应用层通过composer来获取。而grpc也可以通过官方提供的工具打包各个语言的客户端代码。

   rpc服务端,rpc客户端 通过tcp协议交换。

3. 消息总线，有些场景是不适合选择rpc的，比如下单成功后发优惠券，发积分等等。订单中心不能每次都要去调用优惠中心和积分中心，订单中心需要在消息总线的后台添加一个自己业务下的订单创建成功发布事件。优惠中心、积分中心需要去消息总线的后台找到订单创建成功发布事件，去订阅此事件。

4. 服务治理相关，服务注册、服务发现、业界模式，有边车模式 sidecar. 代表有lsto. 通常会有一个dp（data plane）数据面板负责流量劫持处理。还有一个cp (controll plane) 控制面板。

5. 方法论，DDD 领域驱动 是一套基于业务设计的方法论，与微服务相得益彰。通过 战术、战略相关设计思想，设计出的服务都是业务内聚的。且边界清晰，即便是单体中，服务与服务间也是通过限界上下午隔离的，拆分的时候也很好拆分。需要熟悉的概念有： 限界上下文，通用语言（是根基），领域模型抽象的好与坏与对通用语言的整理和理解有很大关系。聚合根、实体、值对象、服务等，同时还涉及门面、防腐层等思想。

（我们知道，除了监控、调用链追踪、API 网关等服务治理系统的开发之外，微服务还有另外一个更加重要的工作，那就是针对公司的业务，合理地做微服务拆分。而领域驱动设计恰好就是用来指导划分服务的，做好领域驱动设计的关键是，看你对自己所做业务的熟悉程度，而并不是对领域驱动设计这个概念本身的掌握程度。即便你对领域驱动搞得再清楚，但是对业务不熟悉，也并不一定能做出合理的领域设计）


上述第4点的作用，有效统一管理，每个服务的修改更新能够及时发现，避免服务间调用失败。



三高：高流量、高并发、高性能的分布式系统的设计及应用套路

1. 系统拆分，服务化。
2. 缓存
3. MQ 面相业务的消息总线，提高异步，发布订阅，解耦。
4. 数据库，主从，多写，多读，mgr,pxc. 分库基因分表。


高并发：

1. 应用缓存
	缓存回收算法： lru,lfu：如 openresty worker内多级缓存，共享缓存 sharedict.
	分布式缓存： memcache 多线程优势，一致性hash

2. 异步、事件驱动架构、消息队列

3. 应用边界，拆分，分布式微服务（分级管理，超时设置，异步调用，服务降级，幂等性设计）

高可用：

1. 负载均衡
2. 限流、降级、鉴权等等 网关



中台： 

稳定的功能沉淀，稳定的向上层提供支持。

能力复用。关键是要能够表达出中台对外提供的能力。

中台之前要考虑愿景是什么，它要解决的问题。


业务技术互相拉动，技术依赖于业务，业务依赖于技术，各个阶段比重不一样，有的时候业务拉着技术走，技术推着业务走，世界上没有纯技术的公司。








